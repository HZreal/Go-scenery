package main

import (
	"fmt"
	"math/rand"
)

/*
*
这个节点实际是链表的头节点而已，用它来表示整个链表(通过它可以到任何一个节点)，但实际上并不是整个链表

1. 为什么使用头节点来代表整个链表？
访问链表的起点：链表是一种线性结构，其元素（节点）的排列有序。链表的操作，无论是添加、删除还是遍历，都需要从链表的起始点开始，这个起始点就是头节点。通过头节点，可以遍历到链表的每一个元素。

简化操作：在很多操作中，尤其是添加和删除节点时，知道头节点的位置可以大大简化逻辑。例如，向链表头部添加一个新节点，只需创建一个新的节点并将其指向原头节点，然后更新头节点为这个新节点即可。

性能优化：对于单向链表，如果有头节点，那么无论链表有多长，访问链表的起始位置的时间复杂度总是O(1)。对于一些特定操作，如在链表头部添加或删除节点，这种设计可以实现高效的执行。为什么使用头节点来代表整个链表？
访问链表的起点：链表是一种线性结构，其元素（节点）的排列有序。链表的操作，无论是添加、删除还是遍历，都需要从链表的起始点开始，这个起始点就是头节点。通过头节点，可以遍历到链表的每一个元素。

简化操作：在很多操作中，尤其是添加和删除节点时，知道头节点的位置可以大大简化逻辑。例如，向链表头部添加一个新节点，只需创建一个新的节点并将其指向原头节点，然后更新头节点为这个新节点即可。

性能优化：对于单向链表，如果有头节点，那么无论链表有多长，访问链表的起始位置的时间复杂度总是O(1)。对于一些特定操作，如在链表头部添加或删除节点，这种设计可以实现高效的执行。

2. 实际上的链表结构
实际上的链表由多个这样的节点通过指针相连组成。每个节点包含两个主要部分：存储的数据（或值）和指向链表中下一个节点的指针（在双向链表中还会有指向前一个节点的指针）。通过这种方式，即使我们只有一个头节点的引用，也能通过遍历操作访问到链表中的每一个节点，从而执行增加、删除、查找等操作。

因此，虽然在代码中我们常常看到只有一个节点的声明来代表整个链表，但实际上整个链表是由这样的多个节点通过“Next”指针串联起来的结构。这种设计既体现了数据结构的逻辑清晰性，也便于在不同的场景下高效地操作链表。

*/
type LinkNode struct {
	Data int8
	Next *LinkNode
}

func test1() {
	node1 := new(LinkNode)
	node1.Data = 1

	node2 := new(LinkNode)
	node2.Data = 2
	node1.Next = node2

	node3 := LinkNode{Data: 3}
	node2.Next = &node3

	nowNode := node1
	for {
		if nowNode != nil {
			fmt.Printf("%T  ", nowNode)
			fmt.Println("nowNode.Data = ", nowNode.Data)
			nowNode = nowNode.Next
			continue
		}
		break
	}
}

/*
*
定义链表
*/
type Ring struct {
	prev, next *Ring
	value      int
}

/*
*
初始化 Ring
*/
func (r *Ring) init() *Ring {
	r.prev = r
	r.next = r
	return r
}

func test2() {
	r := new(Ring)
	r.init()
}

// 创建N个节点的循环链表
func newNRings(n int) *Ring {
	if n <= 0 {
		return nil
	}

	r := &Ring{value: rand.Int()}
	tmp := r
	for i := 1; i < n; i++ {
		newNode := &Ring{prev: tmp, value: rand.Int()}
		tmp.next = newNode

		tmp = newNode
	}
	tmp.next = r
	r.prev = tmp
	fmt.Println("r----", r, r.prev, r.value, r.next)
	r1 := r.next
	fmt.Println("r1----", r1, r1.prev, r1.value, r1.next)
	r2 := r1.next
	fmt.Println("r2----", r2, r2.prev, r2.value, r2.next)
	/**
	result below from console:
	r---- &{0x1400000c078 0x1400000c060 2246265063424630037} &{0x1400000c060 0x1400000c048 8784267196909056036} 2246265063424630037 &{0x1400000c048 0x1400000c078 764836491650020610}
	r1---- &{0x1400000c048 0x1400000c078 764836491650020610} &{0x1400000c078 0x1400000c060 2246265063424630037} 764836491650020610 &{0x1400000c060 0x1400000c048 8784267196909056036}
	r2---- &{0x1400000c060 0x1400000c048 8784267196909056036} &{0x1400000c048 0x1400000c078 764836491650020610} 8784267196909056036 &{0x1400000c078 0x1400000c060 2246265063424630037}
	*/
	return r
}
func main() {
	//test1()
	//test2()
	newNRings(3)
}
